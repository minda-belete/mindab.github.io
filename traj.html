
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Animated Names - Zoom + Rank + Period Filter</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.css" rel="stylesheet">
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.12.0/mapbox-gl.js"></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Open Sans', sans-serif;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
    }

    #filterBox {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(24, 12, 84, 0.55);
      color: #FBBBFF;
      padding: 20px;
      border-radius: 12px;
      font-size: 13px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(5px);
      max-width: 220px;
    }

    #filterBox input,
    #filterBox select,
    #filterBox button {
      margin-top: 8px;
      margin-bottom: 10px;
      padding: 6px 10px;
      border: none;
      border-radius: 8px;
      font-size: 13px;
      width: 100%;
      background-color: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    #filterBox button {
      background-color: rgba(255, 179, 51, 0.8);
      color: #000;
      font-weight: bold;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #filterBox button:hover {
      background-color: rgba(255, 179, 51, 1);
    }

    #filterBox h3 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 15px;
      color: #FFB333;
    }
  </style>
</head>
<body>

<div id="filterBox">
  <input type="text" id="NameInput" placeholder="Enter name">
  <select id="PeriodSelect">
    <option value="All">All Periods</option>
    <option value="Ancient History">Ancient History</option>
    <option value="Post-Classical History">Post-Classical History</option>
    <option value="Early Modern Period">Early Modern Period</option>
    <option value="Mid Modern Period">Mid Modern Period</option>
    <option value="Contemporary Period">Contemporary Period</option>
  </select>
  <button onclick="applyFilter()">Filter</button>
  <button onclick="resetFilter()">Reset</button>
</div>

<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoibWluZGFiZWxldGUiLCJhIjoiY21hNmVkZnlwMG9yYjJpczZnamdneDc3biJ9.SJXyYEKI9OlRARaDr2c9lQ';

const tilesetId = 'mindabelete.bd-academia-test';
const layerName = 'bd-academia-test';
const MAX_ANIMATED = 100000;
const steps = 100;
const animations = [];
let originalAnimations = [], originalRoutes = [];

const map = new mapboxgl.Map({
  container: 'map',
  style: 'mapbox://styles/mapbox/navigation-night-v1',
  center: [0, 51],
  zoom: 1,
  projection: 'globe'
});

map.on('style.load', () => {
  map.setFog({});
  map.getStyle().layers.filter(l => l.type === 'symbol' && l.layout?.['text-field'])
    .forEach(layer => map.setLayoutProperty(layer.id, 'visibility', 'none'));
});

map.on('load', () => {
  map.addSource('vector-points', {
    type: 'vector',
    url: `mapbox://${tilesetId}`
  });

  map.addLayer({
    id: 'point-preview',
    source: 'vector-points',
    'source-layer': layerName,
    type: 'circle',
    paint: { 'circle-radius': 0, 'circle-color': '#00ffcc' },
    filter: ['==', ['get', 'type'], 'origin']
  });

  map.addSource('all-routes', {
    type: 'geojson',
    data: { type: 'FeatureCollection', features: [] }
  });

  map.addLayer({
    id: 'routes-layer',
    source: 'all-routes',
    type: 'line',
    paint: { 'line-color': '#ff0000', 'line-width': 0.5 }
  });

  map.addSource('moving-points', {
    type: 'geojson',
    data: { type: 'FeatureCollection', features: [] }
  });

  map.addLayer({
    id: 'moving-symbols',
    source: 'moving-points',
    type: 'symbol',
    layout: {
      'text-field': ['get', 'person_name'],
      'text-font': [
        'step',
        ['get', 'rank'],
        ['Open Sans Light'],   // rank < 20
        20, ['Open Sans Regular'],
        30, ['Open Sans Semibold'],
        35, ['Open Sans Bold']
      ],
      'text-size': [
        'interpolate', ['linear'], ['get', 'rank'],
        9, 8,
        20, 8,
        30, 12, 
        35, 24,
        40, 36
      ],
      'text-rotation-alignment': 'map',
      'text-writing-mode': ['horizontal'],
      'text-justify': 'center',
      'text-allow-overlap': true,
      'text-ignore-placement': true
    },
    paint: {
      'text-color': '#fff',
      'text-halo-color': '#000',
      'text-halo-width': 1,
      'text-opacity': [
        'step',
        ['zoom'],
        [ // zoom 0–2
          'step',
          ['get', 'rank'],
          0,
          35, 1
        ],
        3, [ // zoom 3–4
          'step',
          ['get', 'rank'],
          0,
          30, 1
        ],
        5, [ // zoom 5–6
          'step',
          ['get', 'rank'],
          0,
          20, 1
        ],
        7, 1 // zoom 7+: show all
      ]
    }
  });

  map.once('idle', () => {
    const features = map.queryRenderedFeatures({ layers: ['point-preview'] });
    const sorted = features.sort((a, b) => Number(b.properties.rank) - Number(a.properties.rank));
    const selected = sorted.slice(0, MAX_ANIMATED);

    const allRoutes = [], allPoints = [];

    selected.forEach(f => {
      const { origin_lon, origin_lat, dest_lon, dest_lat, rank, person_name, big_period } = f.properties;
      const origin = [parseFloat(origin_lon), parseFloat(origin_lat)];
      const dest = [parseFloat(dest_lon), parseFloat(dest_lat)];
      const route = {
        type: 'Feature',
        properties: { person_name },
        geometry: { type: 'LineString', coordinates: [origin, dest] }
      };
      const arc = [];
      const dist = turf.length(route);
      for (let i = 0; i < dist; i += dist / steps) {
        arc.push(turf.along(route, i).geometry.coordinates);
      }
      route.geometry.coordinates = arc;
      allRoutes.push(route);
      const point = {
        type: 'Feature',
        geometry: { type: 'Point', coordinates: origin },
        properties: { person_name, rank: Number(rank), bearing: 0, big_period }
      };
      animations.push({ arc, point, step: 0 });
      allPoints.push(point);
    });

    originalAnimations = [...animations];
    originalRoutes = allRoutes;

    map.getSource('all-routes').setData({ type: 'FeatureCollection', features: allRoutes });
    map.getSource('moving-points').setData({ type: 'FeatureCollection', features: allPoints });

    animate();
  });
});

let frameCount = 0;
function animate() {
  frameCount++;
  if (frameCount % 4 === 0) {
    animations.forEach(obj => {
      if (!obj.arc.length) return;
      obj.point.geometry.coordinates = obj.arc[obj.step];
      const next = obj.arc[(obj.step + 1) % obj.arc.length];
      obj.point.properties.bearing = turf.bearing(turf.point(obj.point.geometry.coordinates), turf.point(next));
      obj.step = (obj.step + 1) % obj.arc.length;
    });
    map.getSource('moving-points').setData({
      type: 'FeatureCollection',
      features: animations.map(a => a.point)
    });
  }
  requestAnimationFrame(animate);
}

function applyFilter() {
  const nameInput = document.getElementById("NameInput").value.trim().toLowerCase();
  const selectedPeriod = document.getElementById("PeriodSelect").value;

  const filtered = originalAnimations.filter(obj => {
    const nameMatch = obj.point.properties.person_name.toLowerCase().includes(nameInput);
    const periodMatch = selectedPeriod === 'All' || obj.point.properties.big_period === selectedPeriod;
    return nameMatch && periodMatch;
  });

  animations.length = 0;
  animations.push(...filtered);

  const filteredRoutes = originalRoutes.filter(r =>
    filtered.some(f => f.point.properties.person_name === r.properties.person_name)
  );

  map.getSource('moving-points').setData({
    type: 'FeatureCollection',
    features: animations.map(a => a.point)
  });

  map.getSource('all-routes').setData({
    type: 'FeatureCollection',
    features: filteredRoutes
  });
}

function resetFilter() {
  animations.length = 0;
  animations.push(...originalAnimations);

  map.getSource('moving-points').setData({
    type: 'FeatureCollection',
    features: animations.map(a => a.point)
  });

  map.getSource('all-routes').setData({
    type: 'FeatureCollection',
    features: originalRoutes
  });

  document.getElementById("NameInput").value = '';
  document.getElementById("PeriodSelect").value = 'All';
}
</script>
</body>
</html>

